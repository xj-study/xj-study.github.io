---
title: v0.0.4
---

如何解决 `effect` 硬编码问题呢？

其实很简单，我们一点点来实现，我们假设用户的副作用函数名为 `foo` ，然后在 `effect` 函数里执行，代码如下：
@[code{19-26} js{2,3,6-8}](@src/vue3/v-0.0.2/v0.1.3/index.js)

这样子处理的话，仅仅是多了一步嵌套调用，固化了一个通用的 `effect` 函数而已，用户的副作用函数还不够抽象，还需要进一步改造。

我们可以让 `effect` 函数接收一个类型为 `function` 的参数，实现如下：
@[code{14-26} js{1,6-9}](@src/vue3/v-0.0.2/v0.1.3/index2.js)

整合一下代码之后，
@[code{14-29} js{1-4,13-16}](@src/vue3/v-0.0.2/v0.1.3/index3.js)

这样一来，用户的只需要将副作用函数传给 `effect` 函数执行，就解决了用户副作用函数硬编码问题，不过，问题还没有解决，我们的数据响应系统，是当数据改变时，会自动调用副作用函数，目前的代码实现是调用的 `effect` 函数，显然不合理，这个时候，我们引入一个全局变量 `activeEffect` ，在执行 `effect` 函数时，将传入的参数 `fn` 赋值给全局变量 `activeEffect` 。代码实现如下：
@[code js{1,2,12,13,26}](@src/vue3/v-0.0.2/v0.1.3/index4.js)

<Demo :content="['hello world!', 'hello vue3']"></Demo>

经过上述重构之后，已经达到了副作用函数动态编写的目的。

